{
  "name": "jsel",
  "version": "1.1.4",
  "description": "DOM 3 XPath implementation for JavaScript objects.",
  "engines": {
    "node": ">=0.10.0"
  },
  "author": {
    "name": "Ali Chamas"
  },
  "contributors": [
    {
      "name": "Tim Harrington"
    }
  ],
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.12.x"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/dragonworx/jsel.git"
  },
  "main": "./jsel.js",
  "keywords": [
    "xpath",
    "json",
    "javascript",
    "expression",
    "matching",
    "selector"
  ],
  "licenses": [
    {
      "type": "MIT License",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "readmeFilename": "README.md",
  "_id": "jsel@1.1.4",
  "_from": "jsel@",
  "readme": "## JSEL\r\nDOM 3 XPath implementation for JavaScript object data.\r\n\r\nWritten by Ali Chamas [site](http://www.musicartscience.com.au).\r\n\r\nBased on the npm module \"xpath\" originally written by Cameron McCormack ([blog](http://mcc.id.au/xpathjs)) with thanks to Yaron Naveh ([blog](http://webservices20.blogspot.com/)).\r\n\r\n#### Try Online\r\nTry the interactive editor to test your own data at:\r\n\r\n[dragonworx.github.io/jsel](http://dragonworx.github.io/jsel/)\r\n\r\n#### Contributors:\r\n\r\n* Tim Harrington\r\n\r\n## Install\r\n\r\n#### Node.js / CommonJS\r\nInstall locally with [npm](http://github.com/isaacs/npm):\r\n\r\n    npm install jsel\r\n\r\nThen require the module into your application.\r\n\r\n    var jsel = require('jsel');\r\n    \r\nNow you can wrap your JSON data by using the `jsel()` function and receive a DOM object.\r\n\r\n    var dom = jsel(data);\r\n\r\n#### Runnign in the Browser\r\n\r\nTo run jsel in the browser, just include the `jsel.js` file from the local jsel npm module installation into your web page.\r\n\r\n    <script src='node_modules/jsel/jsel.js'></script>\r\n\r\nYou will receive a global `jsel` object. Use it like you would a regular `jsel` object in NodeJS.\r\n\r\n    var dom = jsel(data);\r\n\r\n## Usage\r\n\r\nJsel allows you to apply XPath expressions against your JavaScript data objects, and return values from them.\r\n\r\nFor example, say you had the following data.\r\n\r\n    var myJsonData = {\r\n        title: 'abc',\r\n        children: [\r\n            {\r\n                foo: 'bar'\r\n            },\r\n            'val'\r\n        ],\r\n        subData: {\r\n            foo: 555,\r\n            foo2: 'bar2'\r\n        }\r\n    };\r\n    \r\nWrap it in a JSel object like this to receive a Document Object Model.\r\n\r\n    var dom = jsel(myJsonData);\r\n\t\r\nYou now have a DOM object which you can apply XPath expressions to and select data from.\r\n\r\nThe DOM object is similar to an XMLDocument and has the following methods to select either single or multiple elements (The element is an actual sub object from your data, not a copy):\r\n\r\n* `select()` - return a single value from your data\r\n* `selectAll()` - return a result set from your data (array)\r\n\r\nYou can return scalar results from XPath expressions, such as when using the `count()` XPath function.\r\n\r\n**Note** Jsel will return you the actual node values from your data. Think of it like turning any JavaScript object into a walkable XML document.\r\n\r\nGiven the `dom` variable you've just created, the following XPath expressions would all be true.\r\n\r\n    dom.select('count(//*)') === 5;\r\n    dom.select('@title') === 'abc';\r\n    dom.select('//children/*[1]/@foo') === 'bar';\r\n    dom.select('count(//@foo)') === 2;\r\n    dom.select('//@foo[2]') === 555;\r\n    dom.select('count(//children//*)') === 2;\r\n    dom.select('//children/*[2]') === 'val';\r\n    dom.select('name(//children/*[2])') === 'string';\r\n    dom.select('name(*/*[2])') === 'subData';\r\n    dom.select('*/children/*[2]/text()') === 'val';\r\n    dom.selectAll('//@foo') === ['bar', 555];\r\n\r\nJsel supports the following [XPath functions](https://developer.mozilla.org/en-US/docs/Web/XPath/Functions): `last`, `position`, `count`, `match`, `replace`, `id`, `name`, `string`, `concat`, `starts-with`, `contains`, `substring-before`, `substring-after`, `substring`, `string-length`, `normalize-space`, `translate`, `boolean`, `not`, `true`, `false`, `lang`, `number`, `sum`, `floor`, `ceiling`, `round`.\r\n\r\n#### Schemas\r\n\r\nBy default, JSel works with JavaScript objects by treating simple values of object keys as attributes (eg. a key value where the value is a string, number or boolean), and values as objects as elements.\r\n\r\nSince Jsel converts all string, number or boolean values to attributes, and all object or array values to named children, you don't even need to create a schema if you are working with JSON data, it all just works out of the box.\r\n\r\nHowever you can override this default behaviour by defining a set of callbacks which resolve the schema of each node in your data as they are being walked by the XPath engine.\r\n\r\nTo do so, create an object with function values for some or all of the following keys:\r\n\r\n    var schema = {\r\n\t    /*@param {*} node A node from your data\r\n\t\t* @returns {string} The element name of the node\r\n\t\t*/\r\n\t    nodeName: function(node) {},\r\n\t\t/*@param {*} node A node from your data\r\n\t\t* @returns {Array} The children of the node\r\n\t\t*/\r\n\t    childNodes: function(node) {},\r\n\t\t/*@param {*} node A node from your data\r\n\t\t* @returns {Object} A key/value object of the node's attributes\r\n\t\t*/\r\n\t    attributes: function(node) {},\r\n\t\t/*@param {*} node A node from your data - you can use text() in the XPath expression to select this value\r\n\t\t* @returns {*} The value of the node\r\n\t\t*/\r\n\t    nodeValue: function(node) {},\r\n\t}\r\n\r\nThese properties make up the structure of your data, as according to XPath. You now have total control of how to interpret these values from each node in your dom as they are being required.\r\n\r\nJsel takes care of caching, so the values are only asked for once. This builds a virtual tree of walkable nodes for the XPath engine whenever you `select` or `selectAll` an expression, and will be cached for subsequent selections of that DOM.\r\n\r\nIt's ok to return `null` from any function. That would be the same as not defining an adapter for that property and just means that there will no way to match that property in an expression.\r\n\r\nOnce you've defined a schema, attach it to your dom object.\r\n\r\n    dom.schema(schema); // set the schema of this DOM object to change how data is searched\r\n\r\nIt's even possible to create a temporary array or object structure for either `childNodes` and/or `attributes` and return that if you would like to simplify your expressions and aggregate your data. Since JSel caches the resolution of each node, it's only processed once and allows you to collect or aggregate inner data to make your expressions more flexible.\r\n\r\nDefining your own schema allows you to completely design how your data is defined, and therefore searchable by XPath. For example, you could define a schema to handle CSV data, and pass a CSV string to jsel so you could find expressions like `//line` or `//line[1]/field[2]`.\r\n\r\n#### Reuse and Share Schemas\r\n\r\nThe great thing about schemas is that once you've written one to support a data type, you can reuse and share that schema every time you access data of that type. You can distribute that schema so that other users can handle that data type too.\r\n\r\nFor example, you could write a schema to unify and normalise the ast tree of [UglifyJS](http://lisperator.net/uglifyjs/ast) and [esprima](http://esprima.org/doc/index.html#ast). Your schema (and mappings) would abstract both structures and you could use a common expression syntax to search both.\r\n\r\n#### Writing Schemas for Uniform Data\r\n\r\nIf your data is uniform you could use the same logic for each node in your schema. Since each node will have a common structure, you can simplify how each schema function works for all nodes.\r\n\r\n#### Writing Schemas for Variable Data\r\n\r\nIf your data has variable data schema, you might need to use conditional tests inside your schema such as `if` or `switch` statements. Since each node will vary, you'd need to test each node and return from the schema functions accordingly.\r\n\r\n#### User Nodes\r\n\r\nYou can create virtual nodes which only exist to help walk your data, these are called User Nodes. You create these nodes in your schema definitions to wrap parts of your data during expression evaluation, so that you can test for them during subsequent calls to the schema properties. You would usually do this in your `childNodes` property handler.\r\n\r\nTo create a User Node, just call `jsel.Node(nodeName, value)` and pass the node name and it's value. For example you could wrap a plain string and call it a `data` node so that you could test for that node later, and create more virtual types from that.\r\n\r\n## Mappings\r\n\r\nJsel allows you to use regular expressions against your `nodeName` and `attribute` node values. This means you can use shorthand expressions, or map one expression to many nodeNames. This becomes very powerful when simplifying or abstracting your nodes.\r\n\r\nTo provide your own custom mappings, just pass an object to `dom.map(..)` with key value pairs of find and replace regular expressions. The key matches against your expression, the value matches against the node (`nodeName` or `attribute`).\r\n\r\nFor example, we can tell the dom that when we write \"e\" in our expressions, match it to \"someLongElementName\" nodes.\r\n\r\n    dom.map({\r\n        'e': 'someLongElementName'\r\n    });\r\n\r\n    var result = dom.selectAll('//e');\r\n    // will return any nodes with name \"someLongElementName\"\r\n\r\nWe could also tell the dom that when we write \"person\", match it any node with \"male\" or \"female\" `nodeName` values.\r\n\r\n    dom.map({\r\n        'person': 'male|female'\r\n    });\r\n\r\n    var result = dom.selectAll('//person');\r\n    // will return any nodes with nodeName \"male\" or \"female\"\r\n\r\nWe could even tell the dom that when we write \"person\" or \"human\", match it any node with \"male\" or \"female\" `nodeName` values.\r\n\r\n    dom.map({\r\n        'person|human': 'male|female'\r\n    });\r\n\r\n    var result = dom.selectAll('//human');\r\n    // will return any nodes with nodeName \"male\" or \"female\"\r\n    // as would..\r\n    var result = dom.selectAll('//person');\r\n\r\n## Tests\r\n\r\nInstall [mocha](http://visionmedia.github.io/mocha/#installation) globally\r\n\r\n    npm install -g mocha\r\n\r\nFrom the jsel module root, run mocha with spec reporter option\r\n\r\n    mocha -R spec\r\n\r\nTo run tests in the browser, open the `tests/index.html` file in your browser. They are the same tests.",
  "bugs": {
    "url": "https://github.com/dragonworx/jsel/issues"
  },
  "homepage": "https://github.com/dragonworx/jsel"
}
